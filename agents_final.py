"""
Specialized AI Agents for Vehicle Analysis using PydanticAI
"""
# agents_final.py (top of file)
from dotenv import load_dotenv
import os
import asyncio


# load .env into environment variables
load_dotenv()
from typing import Optional, Dict, Any
from pydantic_ai import Agent, RunContext
from pydantic_ai.models.gemini import GeminiModel
from dataclasses import dataclass
import json
from utils import VehicleDataManager, get_sensor_status, SENSOR_RANGES



gemini_model = GeminiModel(
    model_name="gemini-2.0-flash",
    api_key=os.getenv("GEMINI_API_KEY")
)





@dataclass
class VehicleContext:
    """Context passed to agents"""
    vehicle_id: str
    data_manager: VehicleDataManager


# ============================================================================
# DIAGNOSTIC AGENT - Analyzes current vehicle health and detects issues
# ============================================================================

diagnostic_agent = Agent(
    gemini_model,
    deps_type=VehicleContext,
    system_prompt="""You are an expert automotive diagnostic specialist AI.

Your role is to analyze real-time vehicle sensor data and identify any issues, anomalies, or health concerns.

When analyzing vehicle data, you should:
1. Check all sensor readings against normal operating ranges
2. Identify any values that are abnormal, concerning, or critical
3. Look for patterns that might indicate developing problems
4. Consider the vehicle type when evaluating readings (electric vs petrol vs diesel)
5. Provide clear, specific diagnostics with severity levels

Sensor Value Guidelines:
- Engine Temperature: Normal 85-105Â°C, Warning 105-110Â°C, Critical >110Â°C
- Battery Voltage (12V): Normal 12.4-14.8V, Warning 12.0-12.4V, Critical <12.0V
- Battery Voltage (EV): Normal 300-450V
- Oil Pressure: Normal 200-350 kPa, Warning 150-200 kPa, Critical <150 kPa
- Coolant Temperature: Normal 80-95Â°C, Warning 95-105Â°C, Critical >105Â°C
- Tire Pressure: Normal 30-35 PSI, Warning 25-30 PSI, Critical <25 PSI
- Fuel Level: Normal >25%, Warning 10-25%, Critical <10%
- RPM: Normal 0-3000, High 3000-5000, Very High >5000
- Battery SOC (EV): Normal >20%, Warning 10-20%, Critical <10%

Always provide:
- Overall health status (Excellent/Good/Fair/Poor/Critical)
- List of specific issues found with severity
- Any immediate concerns requiring attention
- Brief explanation of what the readings mean

Be concise but informative. Focus on actionable insights."""
)


@diagnostic_agent.tool
async def get_vehicle_sensor_data(ctx: RunContext[VehicleContext]) -> Dict[str, Any]:
    """
    Fetch all sensor data for the vehicle being diagnosed.
    Returns complete sensor readings from the vehicle's onboard systems.
    """
    vehicle_data = ctx.deps.data_manager.get_vehicle_data(ctx.deps.vehicle_id)
    if not vehicle_data:
        return {"error": "Vehicle not found"}
    
    return {
        "vehicle_id": vehicle_data.get("vehicle_id"),
        "car_type": vehicle_data.get("car_type"),
        "sensors": vehicle_data.get("available_sensor_fields", {})
    }


@diagnostic_agent.tool
async def check_dtc_codes(ctx: RunContext[VehicleContext]) -> Dict[str, Any]:
    """
    Check for Diagnostic Trouble Codes (DTCs) in the vehicle.
    DTCs are error codes generated by the vehicle's onboard diagnostics.
    """
    vehicle_data = ctx.deps.data_manager.get_vehicle_data(ctx.deps.vehicle_id)
    if not vehicle_data:
        return {"dtc_codes": []}
    
    sensors = vehicle_data.get("available_sensor_fields", {})
    dtc_codes = sensors.get("dtc_codes", [])
    
    # Common DTC code meanings
    dtc_meanings = {
        "P0420": "Catalyst system efficiency below threshold - catalytic converter may need replacement",
        "P0301": "Cylinder 1 misfire detected - could be spark plug, fuel injector, or compression issue",
        "P0171": "System too lean - possible vacuum leak or fuel delivery issue",
        "P0300": "Random/multiple cylinder misfire - serious engine problem"
    }
    
    return {
        "dtc_codes": dtc_codes,
        "meanings": {code: dtc_meanings.get(code, "Unknown code") for code in dtc_codes}
    }


# ============================================================================
# MAINTENANCE AGENT - Provides maintenance recommendations and schedules
# ============================================================================

maintenance_agent = Agent(
    gemini_model,
    deps_type=VehicleContext,
    system_prompt="""You are an expert automotive maintenance advisor AI.

Your role is to analyze vehicle data and provide maintenance recommendations, schedules, and preventive care advice.

When providing maintenance guidance, you should:
1. Assess current component wear and condition based on sensor data
2. Recommend maintenance tasks based on vehicle readings
3. Prioritize maintenance by urgency (Immediate/Soon/Routine/Optional)
4. Suggest preventive measures to avoid future problems
5. Consider vehicle type and usage patterns

Common Maintenance Indicators:
- Low oil pressure â†’ Check oil level, potential oil change needed
- High engine/coolant temp â†’ Check coolant level, radiator, thermostat
- Low tire pressure â†’ Inspect tires, check for leaks, inflate to proper PSI
- Low battery voltage â†’ Battery may need charging or replacement
- Low brake fluid â†’ Brake system inspection needed
- High brake temps â†’ Brake pad wear, check brake system
- DTC codes present â†’ Diagnostic scan and repair needed
- Low fuel â†’ Refueling needed

Maintenance Categories:
- IMMEDIATE: Safety critical, address within 24 hours
- SOON: Important, schedule within 1-2 weeks
- ROUTINE: Regular maintenance, schedule within 1 month
- PREVENTIVE: Good practice, can be done at next service

Always provide:
- Prioritized list of recommended maintenance tasks
- Estimated urgency and importance
- Preventive tips to maintain vehicle health
- Cost estimates when relevant (low/medium/high)

Be practical and help the user maintain their vehicle properly."""
)


@maintenance_agent.tool
async def get_vehicle_sensor_data(ctx: RunContext[VehicleContext]) -> Dict[str, Any]:
    """
    Fetch all sensor data for maintenance analysis.
    Returns complete sensor readings to assess maintenance needs.
    """
    vehicle_data = ctx.deps.data_manager.get_vehicle_data(ctx.deps.vehicle_id)
    if not vehicle_data:
        return {"error": "Vehicle not found"}
    
    return {
        "vehicle_id": vehicle_data.get("vehicle_id"),
        "car_type": vehicle_data.get("car_type"),
        "sensors": vehicle_data.get("available_sensor_fields", {})
    }


@maintenance_agent.tool
async def check_fluid_levels(ctx: RunContext[VehicleContext]) -> Dict[str, str]:
    """
    Check all fluid levels in the vehicle (oil, coolant, brake fluid, fuel).
    Returns status of each fluid: normal/low/critical.
    """
    sensors = ctx.deps.data_manager.get_sensor_data(ctx.deps.vehicle_id)
    
    fluid_status = {}
    
    # Check fuel level
    if "fuel_level_percent" in sensors:
        fuel = sensors["fuel_level_percent"]
        if fuel < 10:
            fluid_status["fuel"] = "critical - refuel immediately"
        elif fuel < 25:
            fluid_status["fuel"] = "low - refuel soon"
        else:
            fluid_status["fuel"] = "normal"
    
    # Check brake fluid
    if "brake_fluid_level_percent" in sensors:
        brake = sensors["brake_fluid_level_percent"]
        if brake < 50:
            fluid_status["brake_fluid"] = "critical - safety issue"
        elif brake < 70:
            fluid_status["brake_fluid"] = "low - top up recommended"
        else:
            fluid_status["brake_fluid"] = "normal"
    
    # Check oil pressure (indirect indicator)
    if "oil_pressure_kpa" in sensors:
        oil = sensors["oil_pressure_kpa"]
        if oil < 150:
            fluid_status["oil"] = "critical - low pressure"
        elif oil < 200:
            fluid_status["oil"] = "low - check oil level"
        else:
            fluid_status["oil"] = "normal"
    
    return fluid_status


# ============================================================================
# PERFORMANCE AGENT - Analyzes vehicle performance and efficiency
# ============================================================================

performance_agent = Agent(
    gemini_model,
    deps_type=VehicleContext,
    system_prompt="""You are an expert automotive performance analyst AI.

Your role is to analyze vehicle performance metrics, efficiency, and driving behavior.

When analyzing performance, you should:
1. Evaluate engine/motor performance metrics
2. Assess fuel/energy efficiency
3. Check for performance degradation or issues
4. Identify optimization opportunities
5. Compare current performance to expected ranges

Performance Metrics to Analyze:
- RPM vs Speed correlation (gear efficiency)
- Engine temperature under load
- Battery state of charge (for EVs/hybrids)
- Fuel consumption patterns
- Motor/inverter temperatures (for EVs)
- Brake temperatures (performance driving)
- Acceleration and power delivery

Vehicle Type Considerations:
- Petrol/Diesel: Focus on RPM, fuel efficiency, engine temps
- Electric: Focus on battery SOC, motor temps, regen efficiency
- Hybrid: Balance between engine and electric performance
- Sports cars: Performance metrics, brake temps, high RPM operation
- Trucks: Load capacity, torque delivery, durability

Always provide:
- Overall performance rating (Excellent/Good/Average/Below Average/Poor)
- Specific performance strengths
- Areas for improvement
- Efficiency recommendations
- Driving behavior insights if applicable

Be analytical but practical in your recommendations."""
)


@performance_agent.tool
async def get_vehicle_sensor_data(ctx: RunContext[VehicleContext]) -> Dict[str, Any]:
    """
    Fetch all sensor data for performance analysis.
    Returns complete sensor readings and vehicle specifications.
    """
    vehicle_data = ctx.deps.data_manager.get_vehicle_data(ctx.deps.vehicle_id)
    if not vehicle_data:
        return {"error": "Vehicle not found"}
    
    return {
        "vehicle_id": vehicle_data.get("vehicle_id"),
        "car_type": vehicle_data.get("car_type"),
        "sensors": vehicle_data.get("available_sensor_fields", {})
    }


@performance_agent.tool
async def calculate_efficiency_metrics(ctx: RunContext[VehicleContext]) -> Dict[str, Any]:
    """
    Calculate various efficiency metrics based on current sensor data.
    Returns fuel/energy efficiency, thermal efficiency, and performance ratios.
    """
    sensors = ctx.deps.data_manager.get_sensor_data(ctx.deps.vehicle_id)
    vehicle_type = ctx.deps.data_manager.get_vehicle_type(ctx.deps.vehicle_id)
    
    metrics = {}
    
    # RPM to Speed ratio (indicates gear efficiency)
    if "rpm" in sensors and "speed_kmph" in sensors:
        rpm = sensors["rpm"]
        speed = sensors["speed_kmph"]
        if speed > 0:
            metrics["rpm_per_kmph"] = round(rpm / speed, 2)
            if rpm / speed > 100:
                metrics["gear_efficiency"] = "low gear - high RPM for speed"
            elif rpm / speed < 30:
                metrics["gear_efficiency"] = "high gear - efficient cruising"
            else:
                metrics["gear_efficiency"] = "normal"
        elif rpm > 1200:
            metrics["idle_status"] = "high idle - possible issue"
        else:
            metrics["idle_status"] = "normal idle"
    
    # Battery efficiency (for EVs)
    if "battery_soc" in sensors and "speed_kmph" in sensors:
        soc = sensors["battery_soc"]
        speed = sensors["speed_kmph"]
        metrics["battery_level"] = f"{soc}%"
        if soc < 20:
            metrics["range_concern"] = "low battery - charge soon"
    
    # Thermal efficiency
    if "engine_temp_c" in sensors:
        temp = sensors["engine_temp_c"]
        if 85 <= temp <= 95:
            metrics["thermal_efficiency"] = "optimal operating temperature"
        elif temp < 85:
            metrics["thermal_efficiency"] = "engine not fully warmed up"
        else:
            metrics["thermal_efficiency"] = "running hot - check cooling system"
    
    # Fuel status
    if "fuel_level_percent" in sensors:
        fuel = sensors["fuel_level_percent"]
        metrics["fuel_level"] = f"{fuel}%"
    
    return metrics


# ============================================================================
# MASTER AGENT - Routes queries to appropriate specialized agents
# ============================================================================

master_agent = Agent(
    gemini_model,
    system_prompt="""You are the master vehicle analysis coordinator AI.

Your role is to understand user queries about their vehicle and route them to the appropriate specialist:

1. DIAGNOSTIC AGENT - For questions about:
   - Current vehicle health and status
   - Warning lights or error codes
   - Strange noises or behaviors
   - "What's wrong with my car?"
   - System diagnostics and troubleshooting

2. MAINTENANCE AGENT - For questions about:
   - Service recommendations
   - Maintenance schedules
   - Fluid changes and checks
   - "When should I service my car?"
   - Preventive maintenance advice

3. PERFORMANCE AGENT - For questions about:
   - Vehicle performance and efficiency
   - Fuel economy or range
   - Driving optimization
   - "How is my car performing?"
   - Performance metrics and analysis

Analyze the user's query and respond with ONLY ONE of these exact words:
- "diagnostic"
- "maintenance"
- "performance"

If the query is unclear or could apply to multiple agents, choose the most relevant one.

Examples:
- "Is my car healthy?" â†’ diagnostic
- "Check engine light is on" â†’ diagnostic
- "When should I change oil?" â†’ maintenance
- "How's my fuel efficiency?" â†’ performance
- "Any problems with my vehicle?" â†’ diagnostic
- "What maintenance is needed?" â†’ maintenance"""
)


async def route_query(query: str, vehicle_id: str, data_manager: VehicleDataManager) -> Dict[str, Any]:
    """
    Route user query to appropriate agent and get response.
    
    Args:
        query: User's question about their vehicle
        vehicle_id: Vehicle identifier
        data_manager: VehicleDataManager instance
    
    Returns:
        Dictionary with agent type and response
    """
    # First, use master agent to determine routing
    routing_result = await master_agent.run(query)
    agent_type = routing_result.data.strip().lower()
    
    # Create context for the specialized agent
    context = VehicleContext(vehicle_id=vehicle_id, data_manager=data_manager)
    
    # Route to appropriate agent
    if agent_type == "diagnostic":
        result = await diagnostic_agent.run(
            f"Analyze the vehicle and respond to: {query}",
            deps=context
        )
        return {
            "agent": "diagnostic",
            "response": result.data,
            "vehicle_id": vehicle_id
        }
    
    elif agent_type == "maintenance":
        result = await maintenance_agent.run(
            f"Provide maintenance guidance for: {query}",
            deps=context
        )
        return {
            "agent": "maintenance",
            "response": result.data,
            "vehicle_id": vehicle_id
        }
    
    elif agent_type == "performance":
        result = await performance_agent.run(
            f"Analyze performance regarding: {query}",
            deps=context
        )
        return {
            "agent": "performance",
            "response": result.data,
            "vehicle_id": vehicle_id
        }
    
    else:
        # Default to diagnostic if routing unclear
        result = await diagnostic_agent.run(
            f"Analyze the vehicle and respond to: {query}",
            deps=context
        )
        return {
            "agent": "diagnostic",
            "response": result.data,
            "vehicle_id": vehicle_id
        }


async def get_comprehensive_analysis(vehicle_id: str, data_manager: VehicleDataManager) -> Dict[str, Any]:
    context = VehicleContext(vehicle_id=vehicle_id, data_manager=data_manager)

    try:
        diagnostic_task = diagnostic_agent.run(
            "Perform complete diagnostic analysis of this vehicle. Check all systems and sensors.",
            deps=context
        )

        maintenance_task = maintenance_agent.run(
            "Provide complete maintenance assessment and recommendations for this vehicle.",
            deps=context
        )

        performance_task = performance_agent.run(
            "Analyze overall performance, efficiency, and driving metrics for this vehicle.",
            deps=context
        )

        diagnostic_result, maintenance_result, performance_result = await asyncio.gather(
            diagnostic_task,
            maintenance_task,
            performance_task,
            return_exceptions=True  # ðŸ”¥ prevents full crash
        )

        def safe_data(result, name):
            if isinstance(result, Exception):
                return {
            "status": "failed",
            "agent": name,
            "error": repr(result)
        }
                return f"{name} analysis failed"
            return {
        "status": "success",
        "output": result.data
    }

        return {
            "vehicle_id": vehicle_id,
            "diagnostic": safe_data(diagnostic_result, "diagnostic"),
            "maintenance": safe_data(maintenance_result, "maintenance"),
            "performance": safe_data(performance_result, "performance"),
        }

    except Exception as e:
        print("[FATAL ANALYSIS ERROR]", repr(e))
        raise

